一.内存分配算法的讨论与选择
·动态分区分配策略常用的算法有首次适应、邻近适应、最佳适应与最坏适应四种，不同的算法有其不同的特点。

    1.首次适应(First Fit)算法
      ·空闲分区以地址递增的次序链接。每次分配内存时，从链首开始顺序查找，将找到的大小能满足要求的
       第一个空闲分区分配给作业。
      ·优点:实现最简单，检索速度块，由于检索时并不会优先考虑最适合或是最大的分区，因而反而容易留
           下大的分区，既适合小作业也适合大作业，综合性能最好。
      ·缺点:内存低地址部分容易产生难以利用的外部碎片，而每次检索的时候都会扫描这些外部碎片，增加
           了检索的开销。然而事实上这些外部碎片被合并的可能性也更大。
    
    2.邻近适应(Next Fit)算法
      ·由首次适应算法演变而来。每次分配内存时，从上次查找结束的位置开始继续查找，从而改善了首次适
       应算法每次都要检索外部碎片的缺点。
      ·优点:实现也较简单，优化了首次适应的缺点，降低了检索时的开销。
      ·缺点:其检索特点会使得高地址部分被优先用完，而高地址的分区往往是大分区，因而会导致大作业无
           法被装入，导致内存的利用率并不如首次适应算法。
    
    3.最佳适应(Best Fit)算法
      ·空闲分区按大小递增的次序链接，每次分配内存时，找到第一个能满足要求且最小的空闲分区分配给作
       业；或者空闲分区按地址递增次序链接，每次检索整个表，找到满足要求且最小的空闲分区作业。
      ·优点:每次都分配大小最合适的分区给作业，因而产生的外部碎片最小，容易保留下大分区，有利于大作
           业。
      ·缺点:由于产生的外部碎片最小，因而也最难被利用，同时由于外部碎片本身并不连续，因而也最难以被
           合并。所以实际上的内存利用率并不如首次适应算法。
    
    4.最坏适应(Worst Fit)算法
      ·空闲分区按大小递减的次序链接，每次分配内存时，找到第一个能满足要求即最大的空闲分区分配给作业；
       或者空闲分区按地址递增次序链接，每次检索整个表，找到满足要求且最大的空闲分区分配给作业。
      ·优点:优先利用大分区，因而容易留下较大的剩余分区，从而减少了外部碎片。
      ·缺点:大的分区很快会被用完，因而并不利于大作业，内存利用率不高。
    
    综上所述:首次适应算法是最简单的、最容易实现的，但却也是最有效的、内存利用率较高的。

二.调度器的结构
·调度器的核心数据结构是队列。整个调度器由七个队列组成，分别是输入队列、用户进程队列、实时进程队列以及
 三个优先级队列，其中实时进程队列与三个优先级队列存放在一个包含四个队列的调度队列数组中。

    1.输入队列(inputqueue)
      ·无差别地从输入文件中顺序读入所有格式符合要求的作业。

    2.用户进程队列(userjobqueue)
      ·从输入队列中读出的、已到达的且内存大小和申请IO资源数量均合法的用户进程将被放入用户进程队列等
       待分配内存与IO资源。

    3.调度队列数组(dispatcherqueues)
      ·dispatcherqueues[0]~dispatcherqueues[4]依次为已经获得内存与IO资源(仅用户进程)的实时
       进程和一、二、三级用户进程。

三.程序框架与子模块描述
·整个程序由四个子模块组成，分别是:调度器模块、进程控制块模块、内存分配模块与IO资源分配模块。

    1.调度器模块(hostd)
      ·程序的主模块，由五段程序组成，分别对应进程调度的五个阶段。

        a.处理命令行参数，根据不同的参数选择相应的内存分配算法，同时打开输入文件，初始化七个调度器队
          列。
        
        b.初始化内存与IO资源。

        c.从输入文件中将格式合法的作业读入输入队列。

        d.初始化计时器。
          
        e.当任一调度队列非空或者有进程在运行时:
          i)将输入队列中已到达的进程出队、检查进程的合法性并放入相应的队列。
          Tips:考虑了不预先分配实时进程内存的情况，因此并未一开始就将进程出队。

            ·实时进程，检查其内存大小是否为符合要求、是否占用IO资源，将不合法的实时进程直接舍弃。
             对合法的实时进程，首先判断是否预先分配了实时进程内存，若已预先分配，则所有的实时进程
             都将指向同一个内存块，并进入实时进程队列由于只有一个CPU，而实时进程又是FCFS的，因
             而不会产生冲突；若未预先分配内存，则申请内存，若内存资源无法满足，该进程PCB保留在输
             入队列中，结束本次分配。
             -可见不预先分配实时进程内存会导致实时进程无法被第一时间满足的情况，因而一般都要预先分
              配实时进程的内存资源。
          
            ·用户进程，检查其内存大小是否超额、IO资源是否超额，但并不分配任何资源，所有检测未通过
             的用户进程PCB都将直接被抛弃，合法的进入用户进程队列。
          
            ·优先级未知，抛弃该PCB同时报错。
          
          ii)将用户进程队列中资源可满足的进程出队并放入相应的优先级队列。

            ·检测当前的内存与IO资源是否可以满足队头进程；
            
            ·只有当两个资源都满足时，用户进程出队，同时分配内存与IO资源；

            ·按进程优先级放入相应的优先级队列。
          
          iii)如果当前进程非空

            ·该进程的剩余CPU时间减少一个QUANTUM；

            ·如果该进程结束，则结束该进程，释放PCB空间，若该进程为用户进程则同时释放内存和IO资源，
             若为实时进程，则保留下内存空间；
            
            ·如果该进程未结束:
              -若为实时进程，跳过该阶段，进入下一阶段；
              -若为用户进程且此时没有其他进程在排队，重启时间片且保持当前优先级不变；
              -否则若当前进程不在RR队列则降低优先级，挂起该进程同时放入相应的优先级队列。
              Tips:实际代码中还考虑了时间片未结束的情况，此时如有更高优先级的进程在排队则保持当前
                   进程优先级同时挂起该进程、插入相应队列。但由于此次Project各级队列的时间片都为
                   1，因而这种情况不会发生，即不会发生时间片未结束的情况。
            
          iv)如果当前进程为空且调度队列非空(此处将实时与用户进程一同考虑)

            ·优先级最高的队列的队头出队；

            ·开始/继续该进程；

            ·若为用户进程则设置时间片。
          
          v)程序sleep(QUANTUM)；

          vi)计时器增加；

          vii)返回e.继续执行。

        f.结束。

    2.进程控制块模块(pcb)
      ·模拟进程PCB，定义了模拟PCB的结构体(实现为队列)以及包括启动PCB、挂起PCB、回收PCB和打印当
       前进程PCB信息等一系列函数。

    3.内存分配模块(mab)
      ·定义了记录内存分配情况的结构体，完成对进程所需内存空间的分配、回收与合并，其中分配提供四个可
       供用户选择的算法。

        a.首次适应(First Fit)算法
          ·未被分配的和被分配的内存块都按照地址由低到高链接为一个链表，以allocated字段来标识分配情
           况，每次搜寻满足要求的低地址内存分配给进程。
        
        b.邻近适应(Next Fit)算法
          ·内存块链接与标记方式与First Fit一致，但是以一个静态指针next_mab指向上一次分配的内存块
           的下一块，并以此作为下一次分配检索时的首内存块。当某次从next_mab开始的检索失败时，将从头
           再检索一次，并修改next_mab。
        
        c.最佳适应(Best Fit)算法
          ·内存块链接与标记方式与First Fit一致，并未将内存块按照大小由小到大重新排序，而是通过每次
           检索整个链表来找到最小且最适合的内存块分配给进程。一方面是考虑到对链表进行排序的时间复杂度
           过大；另一方面是考虑到没有配套的合并算法。

        d.最坏适应(Worst Fit)算法
          ·内存块链接与标记方式与First Fit一致，也没有将内存块按照大小由大到小重新排序，而是通过每次
           检索整个链表来找到最大且合法的内存块分配给进程。原因同最佳适应算法。

    4.IO资源分配模块(rsrc)
      ·定义了记录IO资源总数量的结构体，完成对IO资源的分配与回收。

四.调度策略的缺点与改进
现有调度策略特点:
  ·对实时进程，优先级最高且不可被抢占，一旦被调度就会运行至结束；存在预先分配内存和不预先分配内存两种策略，
   两种策略下实时进程的内存均不回收。
  ·对用户进程，内存与运行所需的所有IO资源在作业装入时一次性分配。存在3级优先级且低优先级可被高优先级抢占；
   前两级队列时间片结束时，只有有进程在排队才降低优先级并挂起，否则保持优先级并重启时间片。

    1.对实时进程内存的预先分配与不回收:
      ·采用预分配与不回收策略时，由于实时进程的内存大小是固定的，因此可以保证所有合法的实时进程都能获得内存，
       不会因为内存不足而无法运行。但同时也降低了内存的利用率，当作业队列中没有实时进程时，这部分预分配的内存
       将始终无法被利用。
      ·采用不预分配与不回收策略时，在没有实时进程到达之前，所有内存都可以被用户进程充分地利用，但也可能导致实
       时进程应内存不足而无法得到及时地调度。
      ·两种方法各有各的长处。考虑到实时进程的及时性，第一种策略要更好些。
    
    2.对用户进程内存与IO资源的一次性分配
      ·内存资源的一次性连续分配可能会降低系统的并发度以及内存资源的利用率，因为作业装入内存的代码并非每次都全
       部运行，反而，程序的运行存在着时间局部性和空间局部性两个特点。一个可以采用的改进方式是选择调页机制，即
       只将正在运行的代码或访问的数据所处的页调入内存中。
      ·IO资源的一次性分配破坏了进程死锁的请求并保持条件，可以预防死锁，但也降低了IO资源的利用率，因为某进程在
       一开始分配的IO资源可能在进程要结束时才会使用。一个可以采用的改进方式是动态分配，即允许进程在需要时申请
       IO资源，但需要死锁避免或死锁检测机制来防止死锁的发生。
    
    3.对用户进程的多级队列与可被抢占性
      ·抢占性保证了优先级高的能够很快地得到响应；多级队列保证了每个进程的响应时间不会过长。
      ·同时抢占性也可能导致低优先级的进程长时间等待，出现饥饿现象。一个可以考虑的改进方式是适时提高低优先级进程
       的优先级，如设置一个时钟计时，当时钟计时到了进程还没被调度就提高其优先级。
    
    4.对用户进程优先级的保持
      ·当用户进程时间片结束而运行时间未到，且此时用户队列没有进程在排队时，正在运行的进程将重启时间片重新运行并
       且保持当前的优先级。如此策略在一定程度上保证了新进程与旧进程之间的公平性，旧进程不至于因为优先级降低太多
       而长时间无法被调度，从而降低了旧进程的周转时间。
      ·若采用无进程排队时也降低优先级的策略，则是新进程优先的策略，即保证了新来的进程能够占有更多的CPU时间。